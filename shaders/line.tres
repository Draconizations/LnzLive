[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;

render_mode unshaded, skip_vertex_transform;

uniform int line_width_in_pixels_start = 20;
uniform int fuzz_amount = 0;
uniform int line_width_in_pixels_end = 20;
uniform vec4 color : hint_color = vec4(vec3(1.0), 1.0);
uniform int color_index = 0;
uniform vec4 r_color : hint_color = vec4(vec3(0.0), 1.0);
uniform vec4 l_color : hint_color = vec4(vec3(0.0), 1.0);
varying flat vec2 center_of_line;
varying float right_boundary;
varying float left_boundary;
uniform vec3 ball_world_pos1 = vec3(0.0);
uniform vec3 ball_world_pos2 = vec3(0.0);
uniform sampler2D line_texture: hint_white;
uniform int transparent_index = 0;
uniform sampler2D palette: hint_white;

float random (float x) {
    return fract(sin(dot(vec2(x),
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

vec3 get_shifted_color(int palette_index) {
	int modded_color = color_index - int(mod(float(color_index), 10.0));
	int amount_to_shift_index = int(mod(float(palette_index), 10.0));
	int new_palette_index = modded_color + amount_to_shift_index;
	vec3 new_color = texture(palette, vec2(float(new_palette_index)/256.0, 0.0)).rgb;
	return new_color;
}

void fragment() {
	float inverse_camera_scale = 1.0 / ORTHO_SIZE;
	vec2 st = FRAGCOORD.xy;
	
	// Artificially scale up the screen depending on camera scale
    // As long as the camera scale is exact (0.5, 0.125, 2.0 etc) then this will give
    // pixel perfect scaling
	vec2 absolute_center = floor(floor(center_of_line / inverse_camera_scale) * inverse_camera_scale);
    st = floor(floor(st / inverse_camera_scale) * inverse_camera_scale);
	float right_boundary_scaled = floor(right_boundary);
	float left_boundary_scaled = floor(left_boundary);
	
	// FUZZING
    // Find random number based on y-pixel, offset to center of line
    float r = random(st.y + absolute_center.y);
    // Stretch random number between -1.0 and 1.0
    r = (r * 2.0) - 1.0;
    // Increase distortion by fuzz amount
    r *= float(fuzz_amount);
    // Scale with camera to allow zooming
    r *= inverse_camera_scale;
    // Offset x line by the final random amount
    st.x += floor(r);
	
	float pct;
	float pct2;
	float pct3;
	
	if(st.x > left_boundary_scaled && st.x < right_boundary_scaled)
		pct = 1.0;
		
	if(st.x > left_boundary_scaled - inverse_camera_scale && st.x < right_boundary_scaled) 
		pct2 = 1.0;
		
	if(st.x > left_boundary_scaled && st.x < right_boundary_scaled + inverse_camera_scale)
		pct3 = 1.0;
		
	pct2 -= pct;
	pct3 -= pct;
	
	vec3 texture_color;
  if (transparent_index > 0 && color_index < 150) {
	  // get the base texture color
	  texture_color = texture(line_texture, UV).rgb;
	  int palette_index = 0;
	  // find the palette index of the base texture color
	  for(int i = 0; i < 256; i++) {
		vec3 palette_color = texture(palette, vec2(float(i)/256.0, 0.0)).rgb;
		if (palette_color == texture_color) {
		  palette_index = i;
		  break;
		  }
		}
	  // if the index of the texture is the same as the transparent color
	  // then palette shift	
	  if(transparent_index == 1 || (palette_index >= transparent_index && palette_index < transparent_index + 10)) {
		texture_color = get_shifted_color(palette_index);
	  }
	}
  else {
	texture_color = color.rgb;  
}
	
	ALBEDO = vec3(pct * texture_color + pct2 * l_color.rgb + pct3 * r_color.rgb);
	ALPHA = pct + pct2 + pct3;
}

void vertex() {
	float inverse_camera_scale = 1.0 / ORTHO_SIZE;
	
	mat4 projection = PROJECTION_MATRIX * MODELVIEW_MATRIX;
	
	// Find the original position of the vertex
	vec4 vert_in_clip_space = projection * vec4(VERTEX, 1.0);
	vec2 vert_in_ndc_space = vert_in_clip_space.xy / vert_in_clip_space.w;
	
	// Find the opposite pair of the vertex.
	// The mesh has a slight x-width to allow us to find the orientation later
	// So when we come to give the line a fixed pixel width,
	// We need to remove that x-width from the total later.
	vec4 paired_point = vec4(VERTEX + vec3(-VERTEX.x, 0, 0), 1.0);
	vec4 paired_point_clip_space = projection * paired_point;
	vec2 paired_point_ndc_space = paired_point_clip_space.xy / paired_point_clip_space.w;
	
	// Find the opposite end of the line
	vec4 next_point = vec4(VERTEX + vec3(0, -1.0, 0), 1.0);
	vec4 next_point_clip_space = projection * next_point;
	vec2 next_point_ndc_space = next_point_clip_space.xy / next_point_clip_space.w;
	
	// Find the normal, i.e. direction we want to shove the vertices
	vec2 line_direction_onscreen = normalize(next_point_ndc_space - vert_in_ndc_space);
	vec2 normal = vec2(-line_direction_onscreen.y, line_direction_onscreen.x);
	
	// Depending on which side of the mesh this vertex is on,
	// We want to shove the vertex either left or right
	float orientation = 1.0;
	if (VERTEX.x < 0.0 ) {
		orientation = -1.0;
	}
	
	// Depending on line end, set line width
	float line_width_in_pixels = float(line_width_in_pixels_start);
	if(VERTEX.y < 0.0) {
		line_width_in_pixels = float(line_width_in_pixels_end);
	}
	
	// Note - this requires that camera is set to 'keep width'
	vec2 n = floor(normal * line_width_in_pixels * inverse_camera_scale) * orientation;
	vec3 offset = vec3(n / VIEWPORT_SIZE, 0.0);
	
	// Remove the mesh's default x-width from the final output
	vec2 existing_width = vert_in_ndc_space - paired_point_ndc_space;
	offset.xy -= existing_width;
	
	vec2 screen_normal = offset.xy;
	screen_normal += existing_width;
	if (screen_normal.x < 0.0) {
		screen_normal *= -1.0;
	}
	
	// Pad the offset for later
	offset *= 2.0;
	
	float z_pos = vert_in_clip_space.z;
	// Find the minimum z for this line
	if (!(ball_world_pos1 == vec3(0.0) && ball_world_pos2 == vec3(0.0))) {
		vec4 ball_screen_pos1 = PROJECTION_MATRIX * INV_CAMERA_MATRIX * vec4(ball_world_pos1, 1.0);
		vec4 ball_screen_pos2 = PROJECTION_MATRIX * INV_CAMERA_MATRIX * vec4(ball_world_pos2, 1.0);
		z_pos = max(ball_screen_pos1.z, ball_screen_pos2.z);
	}
	VERTEX = vec3(vert_in_ndc_space, z_pos + 0.001 / 1000.0) + offset;
	
	// Calculate center fragcoord. Do in vertex shader to avoid calculating per frag.
	vec4 center_view = projection * vec4(vec3(0.0), 1.0);
	vec2 center_ndc = (center_view.xy + 1.0) / 2.0;
	// Must be an exact pixel coordinate or you get strange pixel effects
	center_of_line = floor(center_ndc * VIEWPORT_SIZE);
	
	PROJECTION_MATRIX = mat4(1.0);
	
	// set up left and right bounds for fuzzing
	vec2 right_bound_intersect = center_ndc + (screen_normal * 0.5);
	vec2 left_bound_intersect = center_ndc - (screen_normal * 0.5);
	  
	vec2 vert_moved = ((VERTEX + 1.0) / 2.0).xy;
  
	float gradient = line_direction_onscreen.y / line_direction_onscreen.x;

	float acceptable_x1 = ((vert_moved.y - right_bound_intersect.y) / gradient) + right_bound_intersect.x;
	float acceptable_x2 = ((vert_moved.y - left_bound_intersect.y) / gradient) + left_bound_intersect.x;

	float x_scaled = acceptable_x1 * VIEWPORT_SIZE.x;
	x_scaled = floor(floor(x_scaled * inverse_camera_scale) / inverse_camera_scale);
	right_boundary = x_scaled;
	x_scaled = acceptable_x2 * VIEWPORT_SIZE.x;
	x_scaled = floor(floor(x_scaled * inverse_camera_scale) / inverse_camera_scale);
	left_boundary = x_scaled;
}"

[resource]
resource_local_to_scene = true
shader = SubResource( 1 )
shader_param/line_width_in_pixels_start = 10.0
shader_param/fuzz_amount = 0
shader_param/line_width_in_pixels_end = 10.0
shader_param/color = Color( 1, 1, 1, 1 )
shader_param/color_index = 0
shader_param/r_color = Color( 0, 0, 0, 1 )
shader_param/l_color = Color( 0, 0, 0, 1 )
shader_param/ball_world_pos1 = Vector3( 0, 0, 0 )
shader_param/ball_world_pos2 = Vector3( 0, 0, 0 )
shader_param/transparent_index = 0
