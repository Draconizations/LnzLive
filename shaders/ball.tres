[gd_resource type="ShaderMaterial" load_steps=3 format=2]

[ext_resource path="res://resources/textures/petzpalette.png" type="Texture" id=1]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;

render_mode unshaded, skip_vertex_transform;

uniform int fuzz_amount = 0;
uniform int ball_size = 1;
uniform int outline = -1;
uniform vec4 color : hint_color;
uniform int color_index = 0;
uniform vec4 outline_color : hint_color;
uniform float z_add = .0;
uniform bool has_texture = false;
uniform sampler2D ball_texture: hint_white;
uniform vec2 texture_size;
uniform int transparent_index = 0;
uniform sampler2D palette: hint_white;

varying flat vec2 center_fragcoord;
varying flat vec4 center_view;

float random (float x) {
    return fract(sin(dot(vec2(x),
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

vec3 get_shifted_color(int palette_index) {
	int modded_color = color_index - int(mod(float(color_index), 10.0));
	int amount_to_shift_index = int(mod(float(palette_index), 10.0));
	int new_palette_index = modded_color + amount_to_shift_index;
	vec3 new_color = texture(palette, vec2(float(new_palette_index)/256.0, 0.0)).rgb;
	return new_color;
}

void fragment() {
  vec2 c = center_fragcoord;
  vec2 st = FRAGCOORD.xy;
  
  // FUZZING
  // Find random number based on y-pixel, offset to center of ball
  float r = random(st.y - c.y);
  // Stretch random number between -1.0 and 1.0
  r = (r * 2.0) - 1.0;
  // Increase distortion by fuzz amount
  r *= float(fuzz_amount);
  // Offset x line by the final random amount
  st.x += floor(r);
  
  //OUTLINING
  float pct2;
  vec2 st2 = st;
  int modified_outline = outline;
  if(outline == -1) {
    // no outline
    modified_outline = 0;
  }
  else if(outline == 0) {
    // one sided outline
    st2.x -= 1.0;
    vec2 vec = st2 - c;
    pct2 = step(length(vec), float(ball_size) / 2.0);
	modified_outline = 0;
  } else if (outline == -2) {
    // one sided outline
    st2.x += 1.0;
    vec2 vec = st2 - c;
    pct2 = step(length(vec), float(ball_size) / 2.0);
	modified_outline = 0;
  } else if (outline == -1) {
    pct2 = 0.0;
    modified_outline = 0;
  } else if (outline > 1) {
    vec2 vec = st2 - c;
    pct2 = step(length(vec), float(ball_size) / 2.0);
	modified_outline -= 1;
  } else if (outline == 1) {
    // dotted outline
	float side = sign(st2.x - c.x);
    vec2 vec = st2 - c;
    pct2 = step(length(vec), float(ball_size) / 2.0);
    modified_outline = 0;
	st.x += 1.0 * side;
  } else if (outline == -3) {
	// nose, need to do special here
	vec2 vec = st2 - c;
    pct2 = step(length(vec), float(ball_size) / 2.0);
	modified_outline = 3;
  } else if (outline < -1) {
	// use as debug for now
	float side = sign(st2.x - c.x);
	float side2 = sign(st2.y - c.y);
	st2.x -= 1.0 * side;
	st2.y -= 1.0 * side2;
    vec2 vec = st2 - c;
    pct2 = step(length(vec), float(ball_size) / 2.0);
    modified_outline = 0;
  }
  
  //DRAWING
  vec2 vector_from_center = st - c;
  // Draw a circle.
  // Base ball size gives exact pixel size at camera scale 1.
  float pct = step(length(vector_from_center), (float(ball_size) / 2.0 - float(modified_outline)));

  if(outline != -1)	
 	 pct2 -= pct;

  vec3 texture_color;
  vec2 center_uv = (center_fragcoord / VIEWPORT_SIZE) - (1.0);
  if (transparent_index > 0 && color_index < 150 && has_texture) {
  	float last_distance = -1.0;
	  // get the base texture color
	texture_color = texture(ball_texture, (SCREEN_UV - center_uv) * (1000.0 / texture_size)).rgb;
	  int palette_index = 0;
	  // find the palette index of the base texture color
	  for(int i = 0; i < 256; i++) {
		vec3 palette_color = texture(palette, vec2(float(i)/256.0, 0.0)).rgb;
		if (palette_color == texture_color) {
		  palette_index = i;
		  break;
		  }
		if (transparent_index != 0) {
		float this_distance = abs(distance(palette_color, texture_color));
		if (this_distance < 0.1 && i >= 10 && i < 150 && (this_distance < last_distance || last_distance == -1.0)) {
			texture_color = texture(palette, vec2(float(i)/256.0, 0.0)).rgb;
			palette_index = i;
			last_distance = this_distance;
			}
		}}
	  // if the index of the texture is the same as the transparent color
	  // then palette shift	
	  if(transparent_index == 1 || (palette_index >= transparent_index && palette_index < transparent_index + 10)) {

		texture_color = get_shifted_color(palette_index);

	  }
	}
	else if (transparent_index == 0 && color_index < 150 && has_texture) {
			texture_color = texture(ball_texture, (SCREEN_UV - center_uv) * (1000.0 / texture_size)).rgb;
		}
  else {
	texture_color = color.rgb;  
}
  ALBEDO = vec3(pct * texture_color.rgb + pct2 * outline_color.rgb);
  ALPHA = pct + pct2;
  
  ALPHA_SCISSOR = 1.0;
}

void vertex() {
	// Billboard and retain scaling
	MODELVIEW_MATRIX = INV_CAMERA_MATRIX * mat4(CAMERA_MATRIX[0],CAMERA_MATRIX[1],CAMERA_MATRIX[2],WORLD_MATRIX[3]);
	
	// Find the original position of the vertex
	vec3 vert_in_clip_space = (MODELVIEW_MATRIX * vec4(VERTEX, 1.0)).xyz;
	
	vec4 center_clip_space = MODELVIEW_MATRIX * vec4(vec3(0.0), 1.0);
	// Calculate center fragcoord. Do in vertex shader to avoid calculating per frag.
	center_view = PROJECTION_MATRIX * center_clip_space;
	vec2 center_ndc = (center_view.xy + 1.0) / 2.0;

	center_fragcoord = floor(center_ndc * VIEWPORT_SIZE) + 0.5;
	
	vert_in_clip_space.z = center_clip_space.z;
	vert_in_clip_space.z += z_add * 0.001;
	float b = (float(ball_size) / 2.0 + 0.5 + float(fuzz_amount + 3)) / (VIEWPORT_SIZE.x / 2.0);
	vert_in_clip_space.x = center_clip_space.x + b * sign(vert_in_clip_space.x);
	vert_in_clip_space.y = center_clip_space.y + b * sign(vert_in_clip_space.y);
	
	VERTEX = vert_in_clip_space;
}"

[resource]
resource_local_to_scene = true
shader = SubResource( 1 )
shader_param/fuzz_amount = 0
shader_param/ball_size = 10
shader_param/outline = -1
shader_param/color = Color( 1, 1, 1, 1 )
shader_param/color_index = 0
shader_param/outline_color = Color( 0, 0, 0, 1 )
shader_param/z_add = 0.0
shader_param/has_texture = false
shader_param/texture_size = null
shader_param/transparent_index = 0
shader_param/palette = ExtResource( 1 )
